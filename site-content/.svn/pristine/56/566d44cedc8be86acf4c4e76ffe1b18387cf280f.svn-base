<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../.resources/report.gif" type="image/gif"/><title>GraggBulirschStoerIntegrator.java</title><link rel="stylesheet" href="../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Apache Commons Math</a> &gt; <a href="index.source.html" class="el_package">org.apache.commons.math3.ode.nonstiff</a> &gt; <span class="el_source">GraggBulirschStoerIntegrator.java</span></div><h1>GraggBulirschStoerIntegrator.java</h1><pre class="source lang-java linenums">/*
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the &quot;License&quot;); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package org.apache.commons.math3.ode.nonstiff;

import org.apache.commons.math3.analysis.solvers.UnivariateSolver;
import org.apache.commons.math3.exception.DimensionMismatchException;
import org.apache.commons.math3.exception.MaxCountExceededException;
import org.apache.commons.math3.exception.NoBracketingException;
import org.apache.commons.math3.exception.NumberIsTooSmallException;
import org.apache.commons.math3.ode.ExpandableStatefulODE;
import org.apache.commons.math3.ode.events.EventHandler;
import org.apache.commons.math3.ode.sampling.AbstractStepInterpolator;
import org.apache.commons.math3.ode.sampling.StepHandler;
import org.apache.commons.math3.util.FastMath;

/**
 * This class implements a Gragg-Bulirsch-Stoer integrator for
 * Ordinary Differential Equations.
 *
 * &lt;p&gt;The Gragg-Bulirsch-Stoer algorithm is one of the most efficient
 * ones currently available for smooth problems. It uses Richardson
 * extrapolation to estimate what would be the solution if the step
 * size could be decreased down to zero.&lt;/p&gt;
 *
 * &lt;p&gt;
 * This method changes both the step size and the order during
 * integration, in order to minimize computation cost. It is
 * particularly well suited when a very high precision is needed. The
 * limit where this method becomes more efficient than high-order
 * embedded Runge-Kutta methods like {@link DormandPrince853Integrator
 * Dormand-Prince 8(5,3)} depends on the problem. Results given in the
 * Hairer, Norsett and Wanner book show for example that this limit
 * occurs for accuracy around 1e-6 when integrating Saltzam-Lorenz
 * equations (the authors note this problem is &lt;i&gt;extremely sensitive
 * to the errors in the first integration steps&lt;/i&gt;), and around 1e-11
 * for a two dimensional celestial mechanics problems with seven
 * bodies (pleiades problem, involving quasi-collisions for which
 * &lt;i&gt;automatic step size control is essential&lt;/i&gt;).
 * &lt;/p&gt;
 *
 * &lt;p&gt;
 * This implementation is basically a reimplementation in Java of the
 * &lt;a
 * href=&quot;http://www.unige.ch/math/folks/hairer/prog/nonstiff/odex.f&quot;&gt;odex&lt;/a&gt;
 * fortran code by E. Hairer and G. Wanner. The redistribution policy
 * for this code is available &lt;a
 * href=&quot;http://www.unige.ch/~hairer/prog/licence.txt&quot;&gt;here&lt;/a&gt;, for
 * convenience, it is reproduced below.&lt;/p&gt;
 * &lt;/p&gt;
 *
 * &lt;table border=&quot;0&quot; width=&quot;80%&quot; cellpadding=&quot;10&quot; align=&quot;center&quot; bgcolor=&quot;#E0E0E0&quot;&gt;
 * &lt;tr&gt;&lt;td&gt;Copyright (c) 2004, Ernst Hairer&lt;/td&gt;&lt;/tr&gt;
 *
 * &lt;tr&gt;&lt;td&gt;Redistribution and use in source and binary forms, with or
 * without modification, are permitted provided that the following
 * conditions are met:
 * &lt;ul&gt;
 *  &lt;li&gt;Redistributions of source code must retain the above copyright
 *      notice, this list of conditions and the following disclaimer.&lt;/li&gt;
 *  &lt;li&gt;Redistributions in binary form must reproduce the above copyright
 *      notice, this list of conditions and the following disclaimer in the
 *      documentation and/or other materials provided with the distribution.&lt;/li&gt;
 * &lt;/ul&gt;&lt;/td&gt;&lt;/tr&gt;
 *
 * &lt;tr&gt;&lt;td&gt;&lt;strong&gt;THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND
 * CONTRIBUTORS &quot;AS IS&quot; AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING,
 * BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
 * FOR A  PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE REGENTS OR
 * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
 * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
 * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.&lt;/strong&gt;&lt;/td&gt;&lt;/tr&gt;
 * &lt;/table&gt;
 *
 * @since 1.2
 */

public class GraggBulirschStoerIntegrator extends AdaptiveStepsizeIntegrator {

    /** Integrator method name. */
    private static final String METHOD_NAME = &quot;Gragg-Bulirsch-Stoer&quot;;

    /** maximal order. */
    private int maxOrder;

    /** step size sequence. */
    private int[] sequence;

    /** overall cost of applying step reduction up to iteration k+1, in number of calls. */
    private int[] costPerStep;

    /** cost per unit step. */
    private double[] costPerTimeUnit;

    /** optimal steps for each order. */
    private double[] optimalStep;

    /** extrapolation coefficients. */
    private double[][] coeff;

    /** stability check enabling parameter. */
    private boolean performTest;

    /** maximal number of checks for each iteration. */
    private int maxChecks;

    /** maximal number of iterations for which checks are performed. */
    private int maxIter;

    /** stepsize reduction factor in case of stability check failure. */
    private double stabilityReduction;

    /** first stepsize control factor. */
    private double stepControl1;

    /** second stepsize control factor. */
    private double stepControl2;

    /** third stepsize control factor. */
    private double stepControl3;

    /** fourth stepsize control factor. */
    private double stepControl4;

    /** first order control factor. */
    private double orderControl1;

    /** second order control factor. */
    private double orderControl2;

    /** use interpolation error in stepsize control. */
    private boolean useInterpolationError;

    /** interpolation order control parameter. */
    private int mudif;

  /** Simple constructor.
   * Build a Gragg-Bulirsch-Stoer integrator with the given step
   * bounds. All tuning parameters are set to their default
   * values. The default step handler does nothing.
   * @param minStep minimal step (sign is irrelevant, regardless of
   * integration direction, forward or backward), the last step can
   * be smaller than this
   * @param maxStep maximal step (sign is irrelevant, regardless of
   * integration direction, forward or backward), the last step can
   * be smaller than this
   * @param scalAbsoluteTolerance allowed absolute error
   * @param scalRelativeTolerance allowed relative error
   */
  public GraggBulirschStoerIntegrator(final double minStep, final double maxStep,
                                      final double scalAbsoluteTolerance,
                                      final double scalRelativeTolerance) {
<span class="fc" id="L171">    super(METHOD_NAME, minStep, maxStep,</span>
          scalAbsoluteTolerance, scalRelativeTolerance);
<span class="fc" id="L173">    setStabilityCheck(true, -1, -1, -1);</span>
<span class="fc" id="L174">    setControlFactors(-1, -1, -1, -1);</span>
<span class="fc" id="L175">    setOrderControl(-1, -1, -1);</span>
<span class="fc" id="L176">    setInterpolationControl(true, -1);</span>
<span class="fc" id="L177">  }</span>

  /** Simple constructor.
   * Build a Gragg-Bulirsch-Stoer integrator with the given step
   * bounds. All tuning parameters are set to their default
   * values. The default step handler does nothing.
   * @param minStep minimal step (must be positive even for backward
   * integration), the last step can be smaller than this
   * @param maxStep maximal step (must be positive even for backward
   * integration)
   * @param vecAbsoluteTolerance allowed absolute error
   * @param vecRelativeTolerance allowed relative error
   */
  public GraggBulirschStoerIntegrator(final double minStep, final double maxStep,
                                      final double[] vecAbsoluteTolerance,
                                      final double[] vecRelativeTolerance) {
<span class="fc" id="L193">    super(METHOD_NAME, minStep, maxStep,</span>
          vecAbsoluteTolerance, vecRelativeTolerance);
<span class="fc" id="L195">    setStabilityCheck(true, -1, -1, -1);</span>
<span class="fc" id="L196">    setControlFactors(-1, -1, -1, -1);</span>
<span class="fc" id="L197">    setOrderControl(-1, -1, -1);</span>
<span class="fc" id="L198">    setInterpolationControl(true, -1);</span>
<span class="fc" id="L199">  }</span>

  /** Set the stability check controls.
   * &lt;p&gt;The stability check is performed on the first few iterations of
   * the extrapolation scheme. If this test fails, the step is rejected
   * and the stepsize is reduced.&lt;/p&gt;
   * &lt;p&gt;By default, the test is performed, at most during two
   * iterations at each step, and at most once for each of these
   * iterations. The default stepsize reduction factor is 0.5.&lt;/p&gt;
   * @param performStabilityCheck if true, stability check will be performed,
     if false, the check will be skipped
   * @param maxNumIter maximal number of iterations for which checks are
   * performed (the number of iterations is reset to default if negative
   * or null)
   * @param maxNumChecks maximal number of checks for each iteration
   * (the number of checks is reset to default if negative or null)
   * @param stepsizeReductionFactor stepsize reduction factor in case of
   * failure (the factor is reset to default if lower than 0.0001 or
   * greater than 0.9999)
   */
  public void setStabilityCheck(final boolean performStabilityCheck,
                                final int maxNumIter, final int maxNumChecks,
                                final double stepsizeReductionFactor) {

<span class="fc" id="L223">    this.performTest = performStabilityCheck;</span>
<span class="fc bfc" id="L224" title="All 2 branches covered.">    this.maxIter     = (maxNumIter   &lt;= 0) ? 2 : maxNumIter;</span>
<span class="fc bfc" id="L225" title="All 2 branches covered.">    this.maxChecks   = (maxNumChecks &lt;= 0) ? 1 : maxNumChecks;</span>

<span class="pc bpc" id="L227" title="1 of 4 branches missed.">    if ((stepsizeReductionFactor &lt; 0.0001) || (stepsizeReductionFactor &gt; 0.9999)) {</span>
<span class="fc" id="L228">      this.stabilityReduction = 0.5;</span>
    } else {
<span class="fc" id="L230">      this.stabilityReduction = stepsizeReductionFactor;</span>
    }

<span class="fc" id="L233">  }</span>

  /** Set the step size control factors.

   * &lt;p&gt;The new step size hNew is computed from the old one h by:
   * &lt;pre&gt;
   * hNew = h * stepControl2 / (err/stepControl1)^(1/(2k+1))
   * &lt;/pre&gt;
   * where err is the scaled error and k the iteration number of the
   * extrapolation scheme (counting from 0). The default values are
   * 0.65 for stepControl1 and 0.94 for stepControl2.&lt;/p&gt;
   * &lt;p&gt;The step size is subject to the restriction:
   * &lt;pre&gt;
   * stepControl3^(1/(2k+1))/stepControl4 &lt;= hNew/h &lt;= 1/stepControl3^(1/(2k+1))
   * &lt;/pre&gt;
   * The default values are 0.02 for stepControl3 and 4.0 for
   * stepControl4.&lt;/p&gt;
   * @param control1 first stepsize control factor (the factor is
   * reset to default if lower than 0.0001 or greater than 0.9999)
   * @param control2 second stepsize control factor (the factor
   * is reset to default if lower than 0.0001 or greater than 0.9999)
   * @param control3 third stepsize control factor (the factor is
   * reset to default if lower than 0.0001 or greater than 0.9999)
   * @param control4 fourth stepsize control factor (the factor
   * is reset to default if lower than 1.0001 or greater than 999.9)
   */
  public void setControlFactors(final double control1, final double control2,
                                final double control3, final double control4) {

<span class="pc bpc" id="L262" title="1 of 4 branches missed.">    if ((control1 &lt; 0.0001) || (control1 &gt; 0.9999)) {</span>
<span class="fc" id="L263">      this.stepControl1 = 0.65;</span>
    } else {
<span class="fc" id="L265">      this.stepControl1 = control1;</span>
    }

<span class="pc bpc" id="L268" title="1 of 4 branches missed.">    if ((control2 &lt; 0.0001) || (control2 &gt; 0.9999)) {</span>
<span class="fc" id="L269">      this.stepControl2 = 0.94;</span>
    } else {
<span class="fc" id="L271">      this.stepControl2 = control2;</span>
    }

<span class="pc bpc" id="L274" title="1 of 4 branches missed.">    if ((control3 &lt; 0.0001) || (control3 &gt; 0.9999)) {</span>
<span class="fc" id="L275">      this.stepControl3 = 0.02;</span>
    } else {
<span class="fc" id="L277">      this.stepControl3 = control3;</span>
    }

<span class="pc bpc" id="L280" title="1 of 4 branches missed.">    if ((control4 &lt; 1.0001) || (control4 &gt; 999.9)) {</span>
<span class="fc" id="L281">      this.stepControl4 = 4.0;</span>
    } else {
<span class="fc" id="L283">      this.stepControl4 = control4;</span>
    }

<span class="fc" id="L286">  }</span>

  /** Set the order control parameters.
   * &lt;p&gt;The Gragg-Bulirsch-Stoer method changes both the step size and
   * the order during integration, in order to minimize computation
   * cost. Each extrapolation step increases the order by 2, so the
   * maximal order that will be used is always even, it is twice the
   * maximal number of columns in the extrapolation table.&lt;/p&gt;
   * &lt;pre&gt;
   * order is decreased if w(k-1) &lt;= w(k)   * orderControl1
   * order is increased if w(k)   &lt;= w(k-1) * orderControl2
   * &lt;/pre&gt;
   * &lt;p&gt;where w is the table of work per unit step for each order
   * (number of function calls divided by the step length), and k is
   * the current order.&lt;/p&gt;
   * &lt;p&gt;The default maximal order after construction is 18 (i.e. the
   * maximal number of columns is 9). The default values are 0.8 for
   * orderControl1 and 0.9 for orderControl2.&lt;/p&gt;
   * @param maximalOrder maximal order in the extrapolation table (the
   * maximal order is reset to default if order &lt;= 6 or odd)
   * @param control1 first order control factor (the factor is
   * reset to default if lower than 0.0001 or greater than 0.9999)
   * @param control2 second order control factor (the factor
   * is reset to default if lower than 0.0001 or greater than 0.9999)
   */
  public void setOrderControl(final int maximalOrder,
                              final double control1, final double control2) {

<span class="pc bpc" id="L314" title="1 of 4 branches missed.">    if ((maximalOrder &lt;= 6) || (maximalOrder % 2 != 0)) {</span>
<span class="fc" id="L315">      this.maxOrder = 18;</span>
    }

<span class="pc bpc" id="L318" title="1 of 4 branches missed.">    if ((control1 &lt; 0.0001) || (control1 &gt; 0.9999)) {</span>
<span class="fc" id="L319">      this.orderControl1 = 0.8;</span>
    } else {
<span class="fc" id="L321">      this.orderControl1 = control1;</span>
    }

<span class="pc bpc" id="L324" title="1 of 4 branches missed.">    if ((control2 &lt; 0.0001) || (control2 &gt; 0.9999)) {</span>
<span class="fc" id="L325">      this.orderControl2 = 0.9;</span>
    } else {
<span class="fc" id="L327">      this.orderControl2 = control2;</span>
    }

    // reinitialize the arrays
<span class="fc" id="L331">    initializeArrays();</span>

<span class="fc" id="L333">  }</span>

  /** {@inheritDoc} */
  @Override
  public void addStepHandler (final StepHandler handler) {

<span class="fc" id="L339">    super.addStepHandler(handler);</span>

    // reinitialize the arrays
<span class="fc" id="L342">    initializeArrays();</span>

<span class="fc" id="L344">  }</span>

  /** {@inheritDoc} */
  @Override
  public void addEventHandler(final EventHandler function,
                              final double maxCheckInterval,
                              final double convergence,
                              final int maxIterationCount,
                              final UnivariateSolver solver) {
<span class="fc" id="L353">    super.addEventHandler(function, maxCheckInterval, convergence,</span>
                          maxIterationCount, solver);

    // reinitialize the arrays
<span class="fc" id="L357">    initializeArrays();</span>

<span class="fc" id="L359">  }</span>

  /** Initialize the integrator internal arrays. */
  private void initializeArrays() {

<span class="fc" id="L364">    final int size = maxOrder / 2;</span>

<span class="pc bpc" id="L366" title="1 of 4 branches missed.">    if ((sequence == null) || (sequence.length != size)) {</span>
      // all arrays should be reallocated with the right size
<span class="fc" id="L368">      sequence        = new int[size];</span>
<span class="fc" id="L369">      costPerStep     = new int[size];</span>
<span class="fc" id="L370">      coeff           = new double[size][];</span>
<span class="fc" id="L371">      costPerTimeUnit = new double[size];</span>
<span class="fc" id="L372">      optimalStep     = new double[size];</span>
    }

    // step size sequence: 2, 6, 10, 14, ...
<span class="fc bfc" id="L376" title="All 2 branches covered.">    for (int k = 0; k &lt; size; ++k) {</span>
<span class="fc" id="L377">        sequence[k] = 4 * k + 2;</span>
    }

    // initialize the order selection cost array
    // (number of function calls for each column of the extrapolation table)
<span class="fc" id="L382">    costPerStep[0] = sequence[0] + 1;</span>
<span class="fc bfc" id="L383" title="All 2 branches covered.">    for (int k = 1; k &lt; size; ++k) {</span>
<span class="fc" id="L384">      costPerStep[k] = costPerStep[k-1] + sequence[k];</span>
    }

    // initialize the extrapolation tables
<span class="fc bfc" id="L388" title="All 2 branches covered.">    for (int k = 0; k &lt; size; ++k) {</span>
<span class="fc bfc" id="L389" title="All 2 branches covered.">      coeff[k] = (k &gt; 0) ? new double[k] : null;</span>
<span class="fc bfc" id="L390" title="All 2 branches covered.">      for (int l = 0; l &lt; k; ++l) {</span>
<span class="fc" id="L391">        final double ratio = ((double) sequence[k]) / sequence[k-l-1];</span>
<span class="fc" id="L392">        coeff[k][l] = 1.0 / (ratio * ratio - 1.0);</span>
      }
    }

<span class="fc" id="L396">  }</span>

  /** Set the interpolation order control parameter.
   * The interpolation order for dense output is 2k - mudif + 1. The
   * default value for mudif is 4 and the interpolation error is used
   * in stepsize control by default.

   * @param useInterpolationErrorForControl if true, interpolation error is used
   * for stepsize control
   * @param mudifControlParameter interpolation order control parameter (the parameter
   * is reset to default if &lt;= 0 or &gt;= 7)
   */
  public void setInterpolationControl(final boolean useInterpolationErrorForControl,
                                      final int mudifControlParameter) {

<span class="fc" id="L411">    this.useInterpolationError = useInterpolationErrorForControl;</span>

<span class="pc bpc" id="L413" title="1 of 4 branches missed.">    if ((mudifControlParameter &lt;= 0) || (mudifControlParameter &gt;= 7)) {</span>
<span class="fc" id="L414">      this.mudif = 4;</span>
    } else {
<span class="fc" id="L416">      this.mudif = mudifControlParameter;</span>
    }

<span class="fc" id="L419">  }</span>

  /** Update scaling array.
   * @param y1 first state vector to use for scaling
   * @param y2 second state vector to use for scaling
   * @param scale scaling array to update (can be shorter than state)
   */
  private void rescale(final double[] y1, final double[] y2, final double[] scale) {
<span class="fc bfc" id="L427" title="All 2 branches covered.">    if (vecAbsoluteTolerance == null) {</span>
<span class="fc bfc" id="L428" title="All 2 branches covered.">      for (int i = 0; i &lt; scale.length; ++i) {</span>
<span class="fc" id="L429">        final double yi = FastMath.max(FastMath.abs(y1[i]), FastMath.abs(y2[i]));</span>
<span class="fc" id="L430">        scale[i] = scalAbsoluteTolerance + scalRelativeTolerance * yi;</span>
      }
    } else {
<span class="fc bfc" id="L433" title="All 2 branches covered.">      for (int i = 0; i &lt; scale.length; ++i) {</span>
<span class="fc" id="L434">        final double yi = FastMath.max(FastMath.abs(y1[i]), FastMath.abs(y2[i]));</span>
<span class="fc" id="L435">        scale[i] = vecAbsoluteTolerance[i] + vecRelativeTolerance[i] * yi;</span>
      }
    }
<span class="fc" id="L438">  }</span>

  /** Perform integration over one step using substeps of a modified
   * midpoint method.
   * @param t0 initial time
   * @param y0 initial value of the state vector at t0
   * @param step global step
   * @param k iteration number (from 0 to sequence.length - 1)
   * @param scale scaling array (can be shorter than state)
   * @param f placeholder where to put the state vector derivatives at each substep
   *          (element 0 already contains initial derivative)
   * @param yMiddle placeholder where to put the state vector at the middle of the step
   * @param yEnd placeholder where to put the state vector at the end
   * @param yTmp placeholder for one state vector
   * @return true if computation was done properly,
   *         false if stability check failed before end of computation
   * @exception MaxCountExceededException if the number of functions evaluations is exceeded
   * @exception DimensionMismatchException if arrays dimensions do not match equations settings
   */
  private boolean tryStep(final double t0, final double[] y0, final double step, final int k,
                          final double[] scale, final double[][] f,
                          final double[] yMiddle, final double[] yEnd,
                          final double[] yTmp)
      throws MaxCountExceededException, DimensionMismatchException {

<span class="fc" id="L463">    final int    n        = sequence[k];</span>
<span class="fc" id="L464">    final double subStep  = step / n;</span>
<span class="fc" id="L465">    final double subStep2 = 2 * subStep;</span>

    // first substep
<span class="fc" id="L468">    double t = t0 + subStep;</span>
<span class="fc bfc" id="L469" title="All 2 branches covered.">    for (int i = 0; i &lt; y0.length; ++i) {</span>
<span class="fc" id="L470">      yTmp[i] = y0[i];</span>
<span class="fc" id="L471">      yEnd[i] = y0[i] + subStep * f[0][i];</span>
    }
<span class="fc" id="L473">    computeDerivatives(t, yEnd, f[1]);</span>

    // other substeps
<span class="fc bfc" id="L476" title="All 2 branches covered.">    for (int j = 1; j &lt; n; ++j) {</span>

<span class="fc bfc" id="L478" title="All 2 branches covered.">      if (2 * j == n) {</span>
        // save the point at the middle of the step
<span class="fc" id="L480">        System.arraycopy(yEnd, 0, yMiddle, 0, y0.length);</span>
      }

<span class="fc" id="L483">      t += subStep;</span>
<span class="fc bfc" id="L484" title="All 2 branches covered.">      for (int i = 0; i &lt; y0.length; ++i) {</span>
<span class="fc" id="L485">        final double middle = yEnd[i];</span>
<span class="fc" id="L486">        yEnd[i]       = yTmp[i] + subStep2 * f[j][i];</span>
<span class="fc" id="L487">        yTmp[i]       = middle;</span>
      }

<span class="fc" id="L490">      computeDerivatives(t, yEnd, f[j+1]);</span>

      // stability check
<span class="pc bpc" id="L493" title="1 of 6 branches missed.">      if (performTest &amp;&amp; (j &lt;= maxChecks) &amp;&amp; (k &lt; maxIter)) {</span>
<span class="fc" id="L494">        double initialNorm = 0.0;</span>
<span class="fc bfc" id="L495" title="All 2 branches covered.">        for (int l = 0; l &lt; scale.length; ++l) {</span>
<span class="fc" id="L496">          final double ratio = f[0][l] / scale[l];</span>
<span class="fc" id="L497">          initialNorm += ratio * ratio;</span>
        }
<span class="fc" id="L499">        double deltaNorm = 0.0;</span>
<span class="fc bfc" id="L500" title="All 2 branches covered.">        for (int l = 0; l &lt; scale.length; ++l) {</span>
<span class="fc" id="L501">          final double ratio = (f[j+1][l] - f[0][l]) / scale[l];</span>
<span class="fc" id="L502">          deltaNorm += ratio * ratio;</span>
        }
<span class="fc bfc" id="L504" title="All 2 branches covered.">        if (deltaNorm &gt; 4 * FastMath.max(1.0e-15, initialNorm)) {</span>
<span class="fc" id="L505">          return false;</span>
        }
      }

    }

    // correction of the last substep (at t0 + step)
<span class="fc bfc" id="L512" title="All 2 branches covered.">    for (int i = 0; i &lt; y0.length; ++i) {</span>
<span class="fc" id="L513">      yEnd[i] = 0.5 * (yTmp[i] + yEnd[i] + subStep * f[n][i]);</span>
    }

<span class="fc" id="L516">    return true;</span>

  }

  /** Extrapolate a vector.
   * @param offset offset to use in the coefficients table
   * @param k index of the last updated point
   * @param diag working diagonal of the Aitken-Neville's
   * triangle, without the last element
   * @param last last element
   */
  private void extrapolate(final int offset, final int k,
                           final double[][] diag, final double[] last) {

    // update the diagonal
<span class="fc bfc" id="L531" title="All 2 branches covered.">    for (int j = 1; j &lt; k; ++j) {</span>
<span class="fc bfc" id="L532" title="All 2 branches covered.">      for (int i = 0; i &lt; last.length; ++i) {</span>
        // Aitken-Neville's recursive formula
<span class="fc" id="L534">        diag[k-j-1][i] = diag[k-j][i] +</span>
                         coeff[k+offset][j-1] * (diag[k-j][i] - diag[k-j-1][i]);
      }
    }

    // update the last element
<span class="fc bfc" id="L540" title="All 2 branches covered.">    for (int i = 0; i &lt; last.length; ++i) {</span>
      // Aitken-Neville's recursive formula
<span class="fc" id="L542">      last[i] = diag[0][i] + coeff[k+offset][k-1] * (diag[0][i] - last[i]);</span>
    }
<span class="fc" id="L544">  }</span>

  /** {@inheritDoc} */
  @Override
  public void integrate(final ExpandableStatefulODE equations, final double t)
      throws NumberIsTooSmallException, DimensionMismatchException,
             MaxCountExceededException, NoBracketingException {

<span class="fc" id="L552">    sanityChecks(equations, t);</span>
<span class="fc" id="L553">    setEquations(equations);</span>
<span class="fc bfc" id="L554" title="All 2 branches covered.">    final boolean forward = t &gt; equations.getTime();</span>

    // create some internal working arrays
<span class="fc" id="L557">    final double[] y0      = equations.getCompleteState();</span>
<span class="fc" id="L558">    final double[] y       = y0.clone();</span>
<span class="fc" id="L559">    final double[] yDot0   = new double[y.length];</span>
<span class="fc" id="L560">    final double[] y1      = new double[y.length];</span>
<span class="fc" id="L561">    final double[] yTmp    = new double[y.length];</span>
<span class="fc" id="L562">    final double[] yTmpDot = new double[y.length];</span>

<span class="fc" id="L564">    final double[][] diagonal = new double[sequence.length-1][];</span>
<span class="fc" id="L565">    final double[][] y1Diag = new double[sequence.length-1][];</span>
<span class="fc bfc" id="L566" title="All 2 branches covered.">    for (int k = 0; k &lt; sequence.length-1; ++k) {</span>
<span class="fc" id="L567">      diagonal[k] = new double[y.length];</span>
<span class="fc" id="L568">      y1Diag[k] = new double[y.length];</span>
    }

<span class="fc" id="L571">    final double[][][] fk  = new double[sequence.length][][];</span>
<span class="fc bfc" id="L572" title="All 2 branches covered.">    for (int k = 0; k &lt; sequence.length; ++k) {</span>

<span class="fc" id="L574">      fk[k]    = new double[sequence[k] + 1][];</span>

      // all substeps start at the same point, so share the first array
<span class="fc" id="L577">      fk[k][0] = yDot0;</span>

<span class="fc bfc" id="L579" title="All 2 branches covered.">      for (int l = 0; l &lt; sequence[k]; ++l) {</span>
<span class="fc" id="L580">        fk[k][l+1] = new double[y0.length];</span>
      }

    }

<span class="pc bpc" id="L585" title="1 of 2 branches missed.">    if (y != y0) {</span>
<span class="fc" id="L586">      System.arraycopy(y0, 0, y, 0, y0.length);</span>
    }

<span class="fc" id="L589">    final double[] yDot1 = new double[y0.length];</span>
<span class="fc" id="L590">    final double[][] yMidDots = new double[1 + 2 * sequence.length][y0.length];</span>

    // initial scaling
<span class="fc" id="L593">    final double[] scale = new double[mainSetDimension];</span>
<span class="fc" id="L594">    rescale(y, y, scale);</span>

    // initial order selection
<span class="fc bfc" id="L597" title="All 2 branches covered.">    final double tol =</span>
        (vecRelativeTolerance == null) ? scalRelativeTolerance : vecRelativeTolerance[0];
<span class="fc" id="L599">    final double log10R = FastMath.log10(FastMath.max(1.0e-10, tol));</span>
<span class="fc" id="L600">    int targetIter = FastMath.max(1,</span>
                              FastMath.min(sequence.length - 2,
                                       (int) FastMath.floor(0.5 - 0.6 * log10R)));

    // set up an interpolator sharing the integrator arrays
<span class="fc" id="L605">    final AbstractStepInterpolator interpolator =</span>
            new GraggBulirschStoerStepInterpolator(y, yDot0,
                                                   y1, yDot1,
                                                   yMidDots, forward,
                                                   equations.getPrimaryMapper(),
                                                   equations.getSecondaryMappers());
<span class="fc" id="L611">    interpolator.storeTime(equations.getTime());</span>

<span class="fc" id="L613">    stepStart = equations.getTime();</span>
<span class="fc" id="L614">    double  hNew             = 0;</span>
<span class="fc" id="L615">    double  maxError         = Double.MAX_VALUE;</span>
<span class="fc" id="L616">    boolean previousRejected = false;</span>
<span class="fc" id="L617">    boolean firstTime        = true;</span>
<span class="fc" id="L618">    boolean newStep          = true;</span>
<span class="fc" id="L619">    boolean firstStepAlreadyComputed = false;</span>
<span class="fc" id="L620">    initIntegration(equations.getTime(), y0, t);</span>
<span class="fc" id="L621">    costPerTimeUnit[0] = 0;</span>
<span class="fc" id="L622">    isLastStep = false;</span>
    do {

      double error;
<span class="fc" id="L626">      boolean reject = false;</span>

<span class="fc bfc" id="L628" title="All 2 branches covered.">      if (newStep) {</span>

<span class="fc" id="L630">        interpolator.shift();</span>

        // first evaluation, at the beginning of the step
<span class="fc bfc" id="L633" title="All 2 branches covered.">        if (! firstStepAlreadyComputed) {</span>
<span class="fc" id="L634">          computeDerivatives(stepStart, y, yDot0);</span>
        }

<span class="fc bfc" id="L637" title="All 2 branches covered.">        if (firstTime) {</span>
<span class="fc" id="L638">          hNew = initializeStep(forward, 2 * targetIter + 1, scale,</span>
                                stepStart, y, yDot0, yTmp, yTmpDot);
        }

<span class="fc" id="L642">        newStep = false;</span>

      }

<span class="fc" id="L646">      stepSize = hNew;</span>

      // step adjustment near bounds
<span class="fc bfc" id="L649" title="All 8 branches covered.">      if ((forward &amp;&amp; (stepStart + stepSize &gt; t)) ||</span>
          ((! forward) &amp;&amp; (stepStart + stepSize &lt; t))) {
<span class="fc" id="L651">        stepSize = t - stepStart;</span>
      }
<span class="fc" id="L653">      final double nextT = stepStart + stepSize;</span>
<span class="fc bfc" id="L654" title="All 6 branches covered.">      isLastStep = forward ? (nextT &gt;= t) : (nextT &lt;= t);</span>

      // iterate over several substep sizes
<span class="fc" id="L657">      int k = -1;</span>
<span class="fc bfc" id="L658" title="All 2 branches covered.">      for (boolean loop = true; loop; ) {</span>

<span class="fc" id="L660">        ++k;</span>

        // modified midpoint integration with the current substep
<span class="fc bfc" id="L663" title="All 6 branches covered.">        if ( ! tryStep(stepStart, y, stepSize, k, scale, fk[k],</span>
                       (k == 0) ? yMidDots[0] : diagonal[k-1],
                       (k == 0) ? y1 : y1Diag[k-1],
                       yTmp)) {

          // the stability check failed, we reduce the global step
<span class="fc" id="L669">          hNew   = FastMath.abs(filterStep(stepSize * stabilityReduction, forward, false));</span>
<span class="fc" id="L670">          reject = true;</span>
<span class="fc" id="L671">          loop   = false;</span>

        } else {

          // the substep was computed successfully
<span class="fc bfc" id="L676" title="All 2 branches covered.">          if (k &gt; 0) {</span>

            // extrapolate the state at the end of the step
            // using last iteration data
<span class="fc" id="L680">            extrapolate(0, k, y1Diag, y1);</span>
<span class="fc" id="L681">            rescale(y, y1, scale);</span>

            // estimate the error at the end of the step.
<span class="fc" id="L684">            error = 0;</span>
<span class="fc bfc" id="L685" title="All 2 branches covered.">            for (int j = 0; j &lt; mainSetDimension; ++j) {</span>
<span class="fc" id="L686">              final double e = FastMath.abs(y1[j] - y1Diag[0][j]) / scale[j];</span>
<span class="fc" id="L687">              error += e * e;</span>
            }
<span class="fc" id="L689">            error = FastMath.sqrt(error / mainSetDimension);</span>

<span class="pc bpc" id="L691" title="1 of 6 branches missed.">            if ((error &gt; 1.0e15) || ((k &gt; 1) &amp;&amp; (error &gt; maxError))) {</span>
              // error is too big, we reduce the global step
<span class="nc" id="L693">              hNew   = FastMath.abs(filterStep(stepSize * stabilityReduction, forward, false));</span>
<span class="nc" id="L694">              reject = true;</span>
<span class="nc" id="L695">              loop   = false;</span>
            } else {

<span class="fc" id="L698">              maxError = FastMath.max(4 * error, 1.0);</span>

              // compute optimal stepsize for this order
<span class="fc" id="L701">              final double exp = 1.0 / (2 * k + 1);</span>
<span class="fc" id="L702">              double fac = stepControl2 / FastMath.pow(error / stepControl1, exp);</span>
<span class="fc" id="L703">              final double pow = FastMath.pow(stepControl3, exp);</span>
<span class="fc" id="L704">              fac = FastMath.max(pow / stepControl4, FastMath.min(1 / pow, fac));</span>
<span class="fc" id="L705">              optimalStep[k]     = FastMath.abs(filterStep(stepSize * fac, forward, true));</span>
<span class="fc" id="L706">              costPerTimeUnit[k] = costPerStep[k] / optimalStep[k];</span>

              // check convergence
<span class="fc bfc" id="L709" title="All 4 branches covered.">              switch (k - targetIter) {</span>

              case -1 :
<span class="pc bpc" id="L712" title="1 of 4 branches missed.">                if ((targetIter &gt; 1) &amp;&amp; ! previousRejected) {</span>

                  // check if we can stop iterations now
<span class="fc bfc" id="L715" title="All 2 branches covered.">                  if (error &lt;= 1.0) {</span>
                    // convergence have been reached just before targetIter
<span class="fc" id="L717">                    loop = false;</span>
                  } else {
                    // estimate if there is a chance convergence will
                    // be reached on next iteration, using the
                    // asymptotic evolution of error
<span class="fc" id="L722">                    final double ratio = ((double) sequence [targetIter] * sequence[targetIter + 1]) /</span>
                                         (sequence[0] * sequence[0]);
<span class="fc bfc" id="L724" title="All 2 branches covered.">                    if (error &gt; ratio * ratio) {</span>
                      // we don't expect to converge on next iteration
                      // we reject the step immediately and reduce order
<span class="fc" id="L727">                      reject = true;</span>
<span class="fc" id="L728">                      loop   = false;</span>
<span class="fc" id="L729">                      targetIter = k;</span>
<span class="pc bpc" id="L730" title="1 of 4 branches missed.">                      if ((targetIter &gt; 1) &amp;&amp;</span>
                          (costPerTimeUnit[targetIter-1] &lt;
                           orderControl1 * costPerTimeUnit[targetIter])) {
<span class="fc" id="L733">                        --targetIter;</span>
                      }
<span class="fc" id="L735">                      hNew = optimalStep[targetIter];</span>
                    }
<span class="fc" id="L737">                  }</span>
                }
                break;

              case 0:
<span class="fc bfc" id="L742" title="All 2 branches covered.">                if (error &lt;= 1.0) {</span>
                  // convergence has been reached exactly at targetIter
<span class="fc" id="L744">                  loop = false;</span>
                } else {
                  // estimate if there is a chance convergence will
                  // be reached on next iteration, using the
                  // asymptotic evolution of error
<span class="fc" id="L749">                  final double ratio = ((double) sequence[k+1]) / sequence[0];</span>
<span class="fc bfc" id="L750" title="All 2 branches covered.">                  if (error &gt; ratio * ratio) {</span>
                    // we don't expect to converge on next iteration
                    // we reject the step immediately
<span class="fc" id="L753">                    reject = true;</span>
<span class="fc" id="L754">                    loop = false;</span>
<span class="pc bpc" id="L755" title="1 of 4 branches missed.">                    if ((targetIter &gt; 1) &amp;&amp;</span>
                        (costPerTimeUnit[targetIter-1] &lt;
                         orderControl1 * costPerTimeUnit[targetIter])) {
<span class="nc" id="L758">                      --targetIter;</span>
                    }
<span class="fc" id="L760">                    hNew = optimalStep[targetIter];</span>
                  }
                }
<span class="fc" id="L763">                break;</span>

              case 1 :
<span class="fc bfc" id="L766" title="All 2 branches covered.">                if (error &gt; 1.0) {</span>
<span class="fc" id="L767">                  reject = true;</span>
<span class="pc bpc" id="L768" title="2 of 4 branches missed.">                  if ((targetIter &gt; 1) &amp;&amp;</span>
                      (costPerTimeUnit[targetIter-1] &lt;
                       orderControl1 * costPerTimeUnit[targetIter])) {
<span class="nc" id="L771">                    --targetIter;</span>
                  }
<span class="fc" id="L773">                  hNew = optimalStep[targetIter];</span>
                }
<span class="fc" id="L775">                loop = false;</span>
<span class="fc" id="L776">                break;</span>

              default :
<span class="fc bfc" id="L779" title="All 6 branches covered.">                if ((firstTime || isLastStep) &amp;&amp; (error &lt;= 1.0)) {</span>
<span class="fc" id="L780">                  loop = false;</span>
                }
                break;

              }

<span class="fc" id="L786">            }</span>
          }
        }
      }

<span class="fc bfc" id="L791" title="All 2 branches covered.">      if (! reject) {</span>
          // derivatives at end of step
<span class="fc" id="L793">          computeDerivatives(stepStart + stepSize, y1, yDot1);</span>
      }

      // dense output handling
<span class="fc" id="L797">      double hInt = getMaxStep();</span>
<span class="fc bfc" id="L798" title="All 2 branches covered.">      if (! reject) {</span>

        // extrapolate state at middle point of the step
<span class="fc bfc" id="L801" title="All 2 branches covered.">        for (int j = 1; j &lt;= k; ++j) {</span>
<span class="fc" id="L802">          extrapolate(0, j, diagonal, yMidDots[0]);</span>
        }

<span class="fc" id="L805">        final int mu = 2 * k - mudif + 3;</span>

<span class="fc bfc" id="L807" title="All 2 branches covered.">        for (int l = 0; l &lt; mu; ++l) {</span>

          // derivative at middle point of the step
<span class="fc" id="L810">          final int l2 = l / 2;</span>
<span class="fc" id="L811">          double factor = FastMath.pow(0.5 * sequence[l2], l);</span>
<span class="fc" id="L812">          int middleIndex = fk[l2].length / 2;</span>
<span class="fc bfc" id="L813" title="All 2 branches covered.">          for (int i = 0; i &lt; y0.length; ++i) {</span>
<span class="fc" id="L814">            yMidDots[l+1][i] = factor * fk[l2][middleIndex + l][i];</span>
          }
<span class="fc bfc" id="L816" title="All 2 branches covered.">          for (int j = 1; j &lt;= k - l2; ++j) {</span>
<span class="fc" id="L817">            factor = FastMath.pow(0.5 * sequence[j + l2], l);</span>
<span class="fc" id="L818">            middleIndex = fk[l2+j].length / 2;</span>
<span class="fc bfc" id="L819" title="All 2 branches covered.">            for (int i = 0; i &lt; y0.length; ++i) {</span>
<span class="fc" id="L820">              diagonal[j-1][i] = factor * fk[l2+j][middleIndex+l][i];</span>
            }
<span class="fc" id="L822">            extrapolate(l2, j, diagonal, yMidDots[l+1]);</span>
          }
<span class="fc bfc" id="L824" title="All 2 branches covered.">          for (int i = 0; i &lt; y0.length; ++i) {</span>
<span class="fc" id="L825">            yMidDots[l+1][i] *= stepSize;</span>
          }

          // compute centered differences to evaluate next derivatives
<span class="fc bfc" id="L829" title="All 2 branches covered.">          for (int j = (l + 1) / 2; j &lt;= k; ++j) {</span>
<span class="fc bfc" id="L830" title="All 2 branches covered.">            for (int m = fk[j].length - 1; m &gt;= 2 * (l + 1); --m) {</span>
<span class="fc bfc" id="L831" title="All 2 branches covered.">              for (int i = 0; i &lt; y0.length; ++i) {</span>
<span class="fc" id="L832">                fk[j][m][i] -= fk[j][m-2][i];</span>
              }
            }
          }

        }

<span class="pc bpc" id="L839" title="1 of 2 branches missed.">        if (mu &gt;= 0) {</span>

          // estimate the dense output coefficients
<span class="fc" id="L842">          final GraggBulirschStoerStepInterpolator gbsInterpolator</span>
            = (GraggBulirschStoerStepInterpolator) interpolator;
<span class="fc" id="L844">          gbsInterpolator.computeCoefficients(mu, stepSize);</span>

<span class="pc bpc" id="L846" title="1 of 2 branches missed.">          if (useInterpolationError) {</span>
            // use the interpolation error to limit stepsize
<span class="fc" id="L848">            final double interpError = gbsInterpolator.estimateError(scale);</span>
<span class="fc" id="L849">            hInt = FastMath.abs(stepSize / FastMath.max(FastMath.pow(interpError, 1.0 / (mu+4)),</span>
                                                0.01));
<span class="fc bfc" id="L851" title="All 2 branches covered.">            if (interpError &gt; 10.0) {</span>
<span class="fc" id="L852">              hNew = hInt;</span>
<span class="fc" id="L853">              reject = true;</span>
            }
          }

        }

      }

<span class="fc bfc" id="L861" title="All 2 branches covered.">      if (! reject) {</span>

        // Discrete events handling
<span class="fc" id="L864">        interpolator.storeTime(stepStart + stepSize);</span>
<span class="fc" id="L865">        stepStart = acceptStep(interpolator, y1, yDot1, t);</span>

        // prepare next step
<span class="fc" id="L868">        interpolator.storeTime(stepStart);</span>
<span class="fc" id="L869">        System.arraycopy(y1, 0, y, 0, y0.length);</span>
<span class="fc" id="L870">        System.arraycopy(yDot1, 0, yDot0, 0, y0.length);</span>
<span class="fc" id="L871">        firstStepAlreadyComputed = true;</span>

        int optimalIter;
<span class="fc bfc" id="L874" title="All 2 branches covered.">        if (k == 1) {</span>
<span class="fc" id="L875">          optimalIter = 2;</span>
<span class="pc bpc" id="L876" title="1 of 2 branches missed.">          if (previousRejected) {</span>
<span class="nc" id="L877">            optimalIter = 1;</span>
          }
<span class="fc bfc" id="L879" title="All 2 branches covered.">        } else if (k &lt;= targetIter) {</span>
<span class="fc" id="L880">          optimalIter = k;</span>
<span class="fc bfc" id="L881" title="All 2 branches covered.">          if (costPerTimeUnit[k-1] &lt; orderControl1 * costPerTimeUnit[k]) {</span>
<span class="fc" id="L882">            optimalIter = k-1;</span>
<span class="fc bfc" id="L883" title="All 2 branches covered.">          } else if (costPerTimeUnit[k] &lt; orderControl2 * costPerTimeUnit[k-1]) {</span>
<span class="fc" id="L884">            optimalIter = FastMath.min(k+1, sequence.length - 2);</span>
          }
        } else {
<span class="fc" id="L887">          optimalIter = k - 1;</span>
<span class="pc bpc" id="L888" title="1 of 4 branches missed.">          if ((k &gt; 2) &amp;&amp;</span>
              (costPerTimeUnit[k-2] &lt; orderControl1 * costPerTimeUnit[k-1])) {
<span class="nc" id="L890">            optimalIter = k - 2;</span>
          }
<span class="fc bfc" id="L892" title="All 2 branches covered.">          if (costPerTimeUnit[k] &lt; orderControl2 * costPerTimeUnit[optimalIter]) {</span>
<span class="fc" id="L893">            optimalIter = FastMath.min(k, sequence.length - 2);</span>
          }
        }

<span class="fc bfc" id="L897" title="All 2 branches covered.">        if (previousRejected) {</span>
          // after a rejected step neither order nor stepsize
          // should increase
<span class="fc" id="L900">          targetIter = FastMath.min(optimalIter, k);</span>
<span class="fc" id="L901">          hNew = FastMath.min(FastMath.abs(stepSize), optimalStep[targetIter]);</span>
        } else {
          // stepsize control
<span class="fc bfc" id="L904" title="All 2 branches covered.">          if (optimalIter &lt;= k) {</span>
<span class="fc" id="L905">            hNew = optimalStep[optimalIter];</span>
          } else {
<span class="fc bfc" id="L907" title="All 4 branches covered.">            if ((k &lt; targetIter) &amp;&amp;</span>
                (costPerTimeUnit[k] &lt; orderControl2 * costPerTimeUnit[k-1])) {
<span class="fc" id="L909">              hNew = filterStep(optimalStep[k] * costPerStep[optimalIter+1] / costPerStep[k],</span>
                               forward, false);
            } else {
<span class="fc" id="L912">              hNew = filterStep(optimalStep[k] * costPerStep[optimalIter] / costPerStep[k],</span>
                                forward, false);
            }
          }

<span class="fc" id="L917">          targetIter = optimalIter;</span>

        }

<span class="fc" id="L921">        newStep = true;</span>

      }

<span class="fc" id="L925">      hNew = FastMath.min(hNew, hInt);</span>
<span class="fc bfc" id="L926" title="All 2 branches covered.">      if (! forward) {</span>
<span class="fc" id="L927">        hNew = -hNew;</span>
      }

<span class="fc" id="L930">      firstTime = false;</span>

<span class="fc bfc" id="L932" title="All 2 branches covered.">      if (reject) {</span>
<span class="fc" id="L933">        isLastStep = false;</span>
<span class="fc" id="L934">        previousRejected = true;</span>
      } else {
<span class="fc" id="L936">        previousRejected = false;</span>
      }

<span class="fc bfc" id="L939" title="All 2 branches covered.">    } while (!isLastStep);</span>

    // dispatch results
<span class="fc" id="L942">    equations.setTime(stepStart);</span>
<span class="fc" id="L943">    equations.setCompleteState(y);</span>

<span class="fc" id="L945">    resetInternalState();</span>

<span class="fc" id="L947">  }</span>

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.7.5.201505241946</span></div></body></html>